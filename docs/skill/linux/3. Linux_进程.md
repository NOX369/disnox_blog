---
id: process
slug: /process
title: Linux 进程
date: 2022-12-01
authors: disnox
tags: [Linux]
keywords: [Linux]

---

<!-- truncate -->

## 1. 基本概念

### 1.1 概述

进程（process）可以看做是系统正在运行的程序。是正在执行的一个程序或者命令。

**进程是资源管理的最小单位，线程是系统调度的最小单位。**一个进程可以拥有多个线程。多个进程之间的资源是相互独立的，一个进程的多个线

程共享这个进程的大多数资源。

每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。

### 1.2 进程占用资源

进程的运行会占用 4 类资源：**CPU、memory、disk、network**。

+ CPU（Central Processing Unit 中央处理单元 ）：lscpu 命令可以查看 CPU 的详细信息。

+ Memory（内存）：free -h 命令可以查看系统内存大小。

+ Disk（磁盘）：df -h 命令可以查看磁盘大小。
+ network（网络）：netstat -a 命令可以查看系统中所有网络连接。

## 2. 进程管理

进程管理可以判断系统的健康状态，查看系统的所有进程，也可以结束相应的进程。

### 2.1 ps aux(查看当前时间节点进程信息)

ps aux | grep disnox（表示查找disnox用户使用的进程）

![Zu92rE.png](https://www.helloimg.com/images/2022/12/01/Zu92rE.png)

+ USER：该进程是由那个用户产生的。
+ PID：进程的ID编号。
+ %CPU：该进程的CPU资源占用百分比。
+ %MEM：该进程的内存资源占用百分比。
+ VSZ：该进程的虚拟内存的大小，单位KB（将磁盘的一部分空间转为虚拟内存使用，在物理内存使用占满后才会用到）。
+ RSS：该进程占用实际物理内存的大小，单位KB。
+ TTY：该进程是在哪个终端上运行的（TTY1-6代表本地控制台终端。TTY1是图形终端，TTY2-6是本地的字符界面终端。PTS/0-255代表虚拟终端）。
+ STAT：进程状态。R：运行、S：睡眠、T：停止、s：包含子进程、+：位于后台。
+ START：该进程启动时间。
+ TIME：该进程占用系统得到运算时间（注意不是系统时间）。
+ COMMAND：产生此进程的命令名

### 2.2 pstree(查看进程树，可以直观的看出父进程与子进程的关系)

pstree -p(将进程树全部展开,查看到对应的PID)

![Zu90u6.png](https://www.helloimg.com/images/2022/12/01/Zu90u6.png)

### 2.3 top(表示进入监听模式，该命令可以动态显示进程的信息变化)

+ top -h：显示帮助
+ top -P：以cpu进行排序
+ top -M：以内存排序
+ top -N：以PID排序
+ 输入q可以退出

![ZuOKTE.png](https://www.helloimg.com/images/2022/12/01/ZuOKTE.png)

+ 第一行是系统信息：21:25:01 是系统时间，Up 6:32是系统运行时间，1 user是系统当前登录用户数量。

+ 第二行是进程信息：Tasks：231 total 表示系统进程总数，running 表示正在运行的进程，sleeping 表示睡眠的进程，stopped 表示已停止的进程，zombie 表示僵尸进程（如果不是0，需要手动检查）。

+ 第三行是 cpu 信息：us 表示用户占用cpu百分比，sy 表示系统占用 cpu 百分比，ni 表示改变过优先级的用户占用百分比。id 表示空闲cpu占用百分比，wa 表示等待输入/输出的进程占用百分比，hi 表示硬件中断请求服务占用百分比，si 表示软件中断请求服务占用百分比，st表示steal time虚拟时间百分比，就是当有虚拟机时虚拟 cpu 等待实体 cpu 的时间百分比。

+ 第四行是物理内存信息：Mem 表示物理内存总量，used 表示以使用的物理内存，free 表示闲置物理内存，buffers 表示缓冲数量。

+ 第五行是交换分区（swap）信息：swap 表示交换分区（虚拟内存）的在大小，used 表示已经使用的交互分区的大小，free表示空闲交换分区的大小，cached 表示作为缓存的交换分区大小。

### 2.4 kill（查看终止进程命令）

kill -l（查看 kill 后面所相应的参数）

![Zu9W1Y.png](https://www.helloimg.com/images/2022/12/01/Zu9W1Y.png)

+ SIGHUP， 该信号让进程⽴即关闭，然后重新读取配置⽂件之后重启
+ SIGINT ，程序终⽌信号，⽤户终⽌前台进程。相当去输出ctrl+c快捷键
+  SIGKILL， ⽤来⽴即结束程序的运⾏，本信号不能被阻塞、忽略。⼀般 ⽤于强制终⽌进程

+ SIGCONT， 信号可以让暂停的进程恢复执⾏，本信号不能被阻断
+  SIGSTOP ，该信号可以暂停前台进程，相当于输⼊crtl+z快捷键。本信号 不能被阻断

**使用 kill命令终止进程**

+ kill -1 32411   （重启PID为32411的进程）
+ kill -9 32425（强制终⽌PID为32425的进程）
+ kill -15 32452（相当于kill 32452，正常结束PID为32452的进程）

## 3. 进程与程序

### 3.1 进程和程序（文件）的区别

+ 程序是静态的，它是一些保存在磁盘上的指令的有序集合，没有任何执行的概念。
+ 进程是一个动态的概念，它是程序执行的过程，包括创建、调度和消亡。

### 3.2 进程和程序的关系

程序包含指令和用户数据，当执行一个程序时，系统将程序中的指令和数据加载到内存，作为进程运行的基本材料，但是进程在运行时将会产生诸如CPU的所有寄存器值，以及存储临时数据的进程堆栈等动态信息。

### 3.3 进程控制块（PCB）

![ZuOBZD.png](https://www.helloimg.com/images/2022/12/01/ZuOBZD.png)

## 4. 进程组织方式

进程是一个动态的过程，可以诞生，也可以杀死。每一个进程必然有一个父进程，可以通过 **pstree** 去查看整个系统的进程关系。

```jsx showLineNumbers
disnox@MSI:/mnt/e/Data/yueq/code$ pstree       // vscode
init─┬─init───bash
     └─init───bash───pstree
```

pstree 是一个用“树状”方式查看当前系统所有进程关系的命令，可以明显看到他们的关系就像人类社会的族谱，大家都有一个共同的祖先 init，每个人都可以生出几个孩子（进程没有性别，自己一个人就能生!)。其中祖先 init是一个非常特别的进程，他没有父进程。

每个进程都有自己的身份证号码（PID），PID是重要的系统资源，它是用以区分各个进程的基本依据。可以使用 **ps （ps -ef | more）**命令来查看进程的 PID。

```jsx showLineNumbers
disnox@MSI:/mnt/e/Data/yueq/code$ ps -ef | more  // vscode
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 20:46 ?        00:00:00 /init       
root        10     1  0 20:46 tty2     00:00:00 /init       
nox         11    10  0 20:46 tty2     00:00:00 -bash       
root        60     1  0 21:46 tty1     00:00:00 /init       
nox         61    60  0 21:46 tty1     00:00:00 -bash       
nox         88    61  0 21:51 tty1     00:00:00 ps -ef      
nox         89    61  0 21:51 tty1     00:00:00 more   
```

第 2 列就是该进程的 PID，第三列 PPID 就是每个进程的父进程的 PID。

## 5. 进程状态

+ 执行态（RUNNING）：进程正在占有CPU。

+ 就绪态（RUNNING）: 进程处于等待队列中等待调度。

+ 浅睡眠（INTERRUPTABLE）：此时进程在等待一个事件的发生或某种系统资源，可响应信号。

+ 深睡眠（UNINTERRUPTABLE）:此时进程在等待一个事件的发生或某种系统资源，无法响应信号。

+ 停止态（STOPPED）：此时进程被暂停。

+ 僵尸态（ZOMBIE）：此时进程不能被调度，但是PCB未被释放。死亡态（DEAD）：这是一个已终止的进程，且PCB将会被释放。

![ZuOCSS.png](https://www.helloimg.com/images/2022/12/01/ZuOCSS.png)

## 6. 进程相关API

### 6.1  获取进程ID和父进程ID

```jsx showLineNumbers
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);//获取当前进程的进程号
pid_t getppid(void);//获取当前进程的父进程号
```

### 6.2 创建进程fork

![ZupgpA.png](https://www.helloimg.com/images/2022/12/02/ZupgpA.png)

:::info 注意

+ fork( )会使得进程本身被复制，因此被创建出来的子进程和父进程几乎是一模一样的。
+ 子进程会从 fork( ) 返回值后的下一条逻辑语句开始运行。
+ 父子进程的执行次序是随机的，无法判断谁先谁后，除非使用特殊机制同步它们。
+ 父子进程是相互独立、互不影响的。

:::

+ **父子进程一样的地方**
  + 实际 UID 和 GID，以及有效 UID 和 GID。
  + 所有的环境变量
  + 进程组ID和会话ID
  + 当前工作路径，除非用 chdir( ) 进行修改。
  + 打开的文件
  + 整个内存空间，包括栈、堆、数据段、代码段、标准IO的缓冲区等等。
  + 信号响应函数

+ **父子进程的区别**
  + 进程的PID
  + 挂起的信号
  + 记录锁

### 6.3 exec函数簇


![Zuzlzz.png](https://www.helloimg.com/images/2022/12/02/Zuzlzz.png)

+ 被加载的文件参数列表必须以自身名字为开始，以 NULL 为结尾。比如要加载执行当前目录下的 a.out 文件，需要一个参数 “abcd” 。

```jsx showLineNumbers
excel("./a.out", "a.out", "abcd", NULL);

const char *argv[3] = {"./a.out", "abcd", NULL};
excev("./a.out", argv);
```

+ exec 函数簇成功执行后，原有的程序代码都将被指定的文件或脚本覆盖，因此这些函数一旦成功后面的代码是无法运行也无法返回的。

> 示例：child.c 和 parent.c

```jsx showLineNumbers
// child.c
#include <stdio.h>
#include <unistd.h>
 
int main(int argc, char *argv[])
{
	printf("child_pid: %d\n", getpid());
  
	return 0;
}
disnox@MSI:/mnt/cde/exce$ gcc child.c -o child

// parent.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
 
int main(int argc, char *argv[])
{
	pid_t pid = fork();
	if(pid > 0){	//父进程
		printf("parent_id: %d\n", getpid());
		exit(0);
	}
	if(pid == 0){	// 子进程
		printf("child_id: %d\n", getpid());
		execl("./child", "child", NULL);	// 执行 child 程序
		printf("hello world\n");			// 这条代码会被覆盖掉
	}
  
	return 0;
}
```

### 6.4 退出进程

![Zup68n.png](https://www.helloimg.com/images/2022/12/02/Zup68n.png)

+ 正常退出指的是调用 **exit( )/_exit( )**，或者使用 **return** 关键字，或者在最后一个线程调用 **pthread_exit( )**。
+ **程序退出处理函数注册**

```jsx showLineNumbers
1 #include <stdlib.h>
2 int atexit(void (*function)(void));
```

> 示例：

```js
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

void f1(void)
{
	printf("%s\n", __FUNCTION__);
}

void f2(void)
{
	printf("%s\n", __FUNCTION__);
}

int main(int argc, char *argv[])
{
	atexit(f1);			// int atexit(void (*function)(void)) 注册一个要在正常流程终止时调用的函数
	atexit(f2);			// 注册函数是一个入栈的过程，先进后出
	printf("hello");	//在缓冲区
    
	//_exit(0);			// 结束程序,但是不会清空缓冲区数据,也不可以处理注册函数
	// exit(0);			// 结束程序,并且可以处理注册函数,以及刷新缓冲区数据
	// return 0;
}
```

### 6.5 等待进程

![ZupUSz.png](https://www.helloimg.com/images/2022/12/02/ZupUSz.png)

+ 处理子进程退出状态值的宏

|          宏          | 含义                                                         |
| :------------------: | :----------------------------------------------------------- |
|  WIFEXITED(status)   | 如果子进程正常退出，则该宏为真。                             |
| WEXITSTATUS(status)  | 如果子进程正常退出，则该宏将获取子进程的退出值。             |
| WIFSIGNALED(status)  | 如果子进程被信号杀死，则该宏为真。                           |
|   WTERMSIG(status)   | 如果子进程被信号杀死，则该宏将获取导致他死亡的信号值。       |
|  WCOREDUMP(status)   | 如果子进程被信号杀死且生成核心转储文件（core dump），则该宏为真。 |
|  WIFSTOPPED(status)  | 如果子进程的被信号暂停，且 **option** 中 **WUNTRACED** 已经被设置时，该宏为真 |
|   WSTOPSIG(status)   | 如果 **WIFSTOPPED(status)** 为真，则该宏将获取导致子进程暂停的信号值。 |
| WIFCONTINUED(status) | 如果子进程被信号 **SIGCONT** 重新置为就绪态，该宏为真。      |

+ 父进程调用wait函数，会等待子进程退出
+ 父进程调用waitpid函数，会等待子进程状态变化 （waitpid函数更通用）









