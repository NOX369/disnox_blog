---
id: system_ios
slug: /system_ios
title: 其它系统IO
date: 2022-12-10
authors: disnox
tags: [Linux, C/C++]
keywords: [Linux, C/C++]
---

## 1. 复制文件描述符

复制文件描述符的一个常见用途是在多进程程序中共享文件。例如，父进程可以打开一个文件，然后通过 `dup2()` 函数复制文件描述符，并通过 `fork()` 函数创建子进程。这样，子进程就可以通过复制的文件描述符访问父进程中打开的文件，并与父进程共享文件。

### 1.1 dup()

`dup()`函数用于在 Linux 系统中复制一个文件描述符。函数原型为：

```jsx showLineNumbers
int dup(int oldfd);
```

> 该函数接受一个参数：
>
> - `oldfd`：指定要复制的文件描述符。
>
> 如果成功复制了文件描述符，则该函数返回新的文件描述符。如果复制文件描述符失败，则返回 -1。

例如，以下代码复制了文件描述符 `fd`：

```jsx showLineNumbers
int newfd = dup(fd);
```

复制文件描述符后，新的文件描述符与原来的文件描述符指向同一个文件，并且文件描述符的当前位置也相同。但是，新的文件描述符可以被独立地操作，而不会影响原来的文件描述符。

注意：复制完文件描述符后，程序应该调用 `close()` 函数关闭复制的文件描述符以释放系统资源。

### 1.2 dup2()

`dup2()`函数用于在 Linux 系统中复制一个文件描述符。函数原型为：

```jsx showLineNumbers
int dup2(int oldfd, int newfd);
```

> 该函数接受两个参数：
>
> - `oldfd`：指定要复制的文件描述符。
> - `newfd`：指定新的文件描述符，如果 `newfd` 已经打开，则它会被关闭。
>
> 如果成功复制了文件描述符，则该函数返回新的文件描述符。如果复制文件描述符失败，则返回 -1。

例如，以下代码复制了文件描述符 `fd`，并将新的文件描述符指定为 10：

```jsx showLineNumbers
int newfd = dup2(fd, 10);
```

复制文件描述符后，新的文件描述符与原来的文件描述符指向同一个文件，并且文件描述符的当前位置也相同。但是，新的文件描述符可以被独立地操作，而不会影响原来的文件描述符。

与 `dup()` 函数不同，`dup2()` 函数允许指定新的文件描述符。这可以在一些情况下提供更多的灵活性。例如，可以通过复制文件描述符来将一个已打开的文件重定向到另一个文件。

## 2. 文件控制

### 2.1 ioctl()

`ioctl()`函数用于在 Linux 系统中控制设备。函数原型为：

```jsx showLineNumbers
int ioctl(int d, int request, ...);
```

> 该函数接受三个参数：
>
> - `d`：指定要控制的设备的文件描述符。
> - `request`：指定要执行的操作。
> - `...`：其他可选参数，用于提供更多信息，根据执行的操作而不同。
>
> 如果成功控制设备，则该函数返回 0。如果控制设备失败，则返回 -1。

`ioctl()` 函数可以执行各种不同的操作，根据所指定的操作类型而不同。例如，可以通过 `ioctl()` 函数控制终端设备的大小、颜色和显示模式，或者控制磁盘驱动器的状态和性能。

为了执行指定的操作，必须向 `ioctl()` 函数提供一个操作类型，这通常是一个由宏定义的整数值。每个操作类型对应一种特定的操作，并且需要提供一定的参数来指定操作的细节。其 request 是一个由底层驱动提供的命令字，这些通用的命令字被放置在头文件 /usr/include/asm-generi/ioctls.h (不同的系统存放位置也许不同) 中，后面的变参也由前面的request 命令字决定。例如，可以使用 `TIOCGWINSZ` 常量作为操作类型，来查询终端设备的窗口大小：

```jsx showLineNumbers
#include <sys/ioctl.h>
#include <stdio.h>

struct winsize ws;

int main(int argc, char *argv[])
{
    ioctl(0, TIOCGWINSZ, &ws);
    printf("width: %d, height: %d\n", ws.ws_col, ws.ws_row);

    return 0;
}
```

上面的代码中，`ioctl()` 函数接受三个参数：文件描述符 0（指定标准输入设备）、操作类型 `TIOCGWINSZ`常量、以及一个指向`winsize`结构体的指针。该函数执行查询操作，并将结果存储在`winsize` 结构体中。最后，通过打印结构体的成员变量来查看终端设备的窗口大小。

### 2.2 fcntl()

`fcntl()`函数用于控制文件描述符的行为。函数原型为：

```jsx showLineNumbers
int fcntl(int fd, int cmd, ...);
```

> 该函数接受三个参数：
>
> - `fd`：指定要控制的文件描述符。
> - `cmd`：指定要执行的操作。
> - `...`：其他可选参数，用于提供更多信息，根据执行的操作而不同。
>
> 如果成功控制文件描述符，则该函数返回 0。如果控制文件描述符失败，则返回 -1。

`fcntl()` 函数可以执行各种不同的操作，根据所指定的操作类型而不同。例如，可以通过 `fcntl()` 函数设置文件描述符的状态和属性，或者控制文件锁的行为。

为了执行指定的操作，必须向 `fcntl()` 函数提供一个操作类型，这通常是一个由宏定义的整数值。每个操作类型对应一种特定的操作，并且需要提供一定的参数来指定操作的细节。例如，可以使用 `F_GETFL` 常量作为操作类型，来查询文件描述符的状态：

```jsx showLineNumbers
int status;
status = fcntl(fd, F_GETFL);
```

该函数可以用来实现文件锁、管道、共享内存等机制。

## 3. 内存映射

mmap() 函数用于在 Linux 系统中映射文件或其他对象到进程的地址空间。该函数的原型为： 

```jsx showLineNumbers
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 
```

> 该函数接受六个参数： 
>
> +  addr：指定映射到进程地址空间的起始地址，如果设为 NULL 则由系统自动选择起始地址。 
>
> + length：指定要映射的字节数。 
>
> + prot：指定映射的内存页的访问权限。 
>
> + flags：指定映射的属性和行为。 
>
> + fd：指定要映射的文件或对象的文件描述符。 
>
> + offset：指定要映射的文件或对象的偏移量。 
>
> 如果成功映射文件或对象，则该函数返回映射的起始地址，否则返回 MAP_FAILED（一个常量，通常为-1）。

mmap() 函数用于将文件或其他对象映射到进程的地址空间，以便进程能够直接访问文件或对象的内容。这种方法可以提高文件访问的效率，因为它允许进程直接操作内存，而不需要通过内核来传输数据。

使用 mmap() 函数的一个常见用途是将一个大文件映射到内存中，以便对其进行高效的读取或修改。例如，在处理大量数据时，可以使用 mmap() 函数将数据文件映射到内存，然后直接对内存中的数据进行处理，而不需要通过磁盘读取和写入来传输数据。

使用 mmap() 函数需要注意以下几点：

- 该函数在 Linux 系统中使用，在其他操作系统中可能不存在或有所不同。
- 使用该函数时，必须指定要映射的文件或对象的文件描述符。
- 在映射文件或对象之后，必须调用 munmap() 函数来取消映射，避免占用过多的内存资源。
- 如果要修改映射的文件或对象，必须使用 msync() 函数来同步内存中的更改到文件或对象中。
- 除了以上提到的参数和用法，mmap() 函数还有一些其他的选项和特性，具体可以参考 Linux 操作系统的相关文档。总之，mmap() 函数是一个非常有用的工具，它可以提高文件访问的效率，并为程序提供更多的灵活性和可扩展性。

例如，下面的代码演示了如何使用`mmap() `函数将一个文件映射到内存中，然后对文件进行修改并同步到文件中：

```jsx showLineNumbers
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

// 要映射的文件名
const char *FILE_NAME = "test.txt";

int main(int argc, char *argv[])
{
	// 打开文件，获取文件描述符
	int fd = open(FILE_NAME, O_RDWR|O_CREAT, S_IRWXU);
	if (fd == -1){
		perror("open() fail");
		exit(EXIT_FAILURE);
	}

	// 获取文件信息，用于指定要映射的字节数
	struct stat st;
	if (fstat(fd, &st) == -1){
		perror("fstat() fail");
		exit(EXIT_FAILURE);
	}
	if (st.st_size == 0){
		fprintf(stderr, "file size is 0\n");
		exit(EXIT_FAILURE);
	}

	// 将文件映射到进程地址空间
	void *p = mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (p == MAP_FAILED){
		perror("mmap() fail");
		exit(EXIT_FAILURE);
	}

	// 对文件内容进行修改
	char *s = (char *)p;
	strcpy(s, "Hello, world!");

	// 同步更改到文件中
	msync(p, st.st_size, MS_SYNC);

	// 取消映射
	munmap(p, st.st_size);

	// 关闭文件
	close(fd);

	return 0;
}
```

















