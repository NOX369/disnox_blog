---
id: system_io
slug: /system_io
title: 系统IO的文件读写
date: 2022-12-10
authors: disnox
tags: [Linux, C/C++]
keywords: [Linux, C/C++]
---

## 1. 基本概念

Linux系统的IO指的是输入/输出（Input/Output）。在Linux中，所有输入和输出都通过文件来完成，因此，Linux系统的IO可以被看作是对文件进行操作。

在Linux系统中，程序通过文件描述符来访问文件，其中，文件描述符是一个整数，用于标识一个文件。每个文件都有一个唯一的文件描述符，程序可以通过文件描述符来读取或写入文件。

在Linux系统中，有三种基本的IO操作：读操作、写操作和错误操作。读操作用于从文件中读取数据，写操作用于向文件中写入数据，错误操作用于检查文件是否发生错误。

在Linux系统中，还可以通过文件状态标志来控制IO操作。文件状态标志是一个整数，用于设置文件的读写模式，如是否允许读操作、是否允许写操作等。

总之，Linux系统的IO操作是通过文件描述符和文件状态标志来完成的。程序可以通过这两个机制来控制文件的读写操作，实现输入输出功能。

## 2 打开文件

按照下面的格式去描述说明 int close(int fd);

`open()`函数用于在 Linux 系统中打开文件。函数原型为：

```jsx showLineNumbers
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

>该函数接受三个参数：
>- `pathname`：指向要打开的文件路径的字符串。
>- `flags`：指定文件的打开模式，如读、写、读写等。
>- `mode`：指定文件的权限，如用户权限、组权限等。
>
>如果打开文件成功，则该函数返回文件描述符。否则，返回 -1。

`flags`参数指定了文件的打开模式，具体可以使用的值有：

- `O_RDONLY`：只读模式，只允许读取文件内容。
- `O_WRONLY`：只写模式，只允许写入文件内容。
- `O_RDWR`：读写模式，既可以读取文件内容，也可以写入文件内容。
- `O_APPEND`：追加模式，每次写入操作都会将数据追加到文件末尾。
- `O_CREAT`：如果文件不存在，则创建。
- `O_EXCL`：如果使用 O_CREAT 选项且文件存在，则创建该文件。
- `O_TRUNC`：表示如果文件存在，则清空文件内容。
- `O_NOCTTY`：如果文件为终端，那么终端不可以作为调用 open( ) 系统调用的那个进程的控制终端。

例如，下面的代码演示了如何使用`open()`函数打开一个文件：

```jsx showLineNumbers
// 打开文件
int fd = open("test.txt", O_RDWR, 0644);
if (fd == -1) {
    // 打开文件失败
    perror("open() fail");
    exit(EXIT_FAILURE);
}
```

## 3. 关闭文件

`close()`函数用于在 Linux 系统中关闭文件。函数原型为：

```jsx showLineNumbers
int close(int fd);
```

> 该函数接受一个参数：
>
> - `fd`：指定要关闭的文件的文件描述符。
>
> 如果关闭文件成功，则该函数返回 0。否则，返回 -1。

注意：重复关闭一个已经关闭了的文件或者尚未打开的文件是安全的。

## 4. 写入文件

`write()`函数用于在 Linux 系统中将数据写入文件。函数原型为：

```jsx showLineNumbers
ssize_t write(int fd, const void *buf, size_t count);
```

> 该函数接受三个参数：
>
> - `fd`：指定要写入的文件的文件描述符。
> - `buf`：指向要写入文件的数据缓冲区的指针。
> - `count`：指定要写入的数据的长度（单位：字节），实际写入的字节小于等于 count。
>
> 如果写入文件成功，则该函数返回实际写入的字节数。如果写入文件时出错，则返回 -1。

注意：在调用 `write()` 函数之前，需要使用 `open()` 函数打开文件。当不再需要对文件进行操作时，需要使用 `close()` 函数关闭文件。

## 5. 读取文件

`read()`函数用于在 Linux 系统中从文件中读取数据。函数原型为：

```jsx showLineNumbers
ssize_t read(int fd, void *buf, size_t count);
```

> 该函数接受三个参数：
>
> - `fd`：指定要读取的文件的文件描述符。
> - `buf`：指向用于存储读取数据的缓冲区的指针。
> - `count`：指定要读取的数据的长度（单位：字节），实际读取的字节小于等于 count。
>
> 如果读取文件成功，则该函数返回实际读取的字节数。如果读取文件时出错，则返回 -1。如果已到达文件末尾，则返回 0。

注意：在调用 `read()` 函数之前，需要使用 `open()` 函数打开文件。当不再需要对文件进行操作时，需要使用 `close()` 函数关闭文件。

## 6. 调整文件位置

`lseek()`函数用于在 Linux 系统中将文件指针移到指定位置。函数原型为：

```jsx showLineNumbers
off_t lseek(int fd, off_t offset, int whence);
```

> 该函数接受三个参数：
>
> - `fd`：指定要操作的文件的文件描述符。
>
> - `offset`：指定文件指针要移到的位置（单位：字节）。
>
> - `whence`：指定文件指针要移到的位置相对于哪个位置。可能的值有：
>
>   + `SEEK_SET`：文件开头
>
>   + `SEEK_CUR`：当前位置
>
>   + `SEEK_END`：文件末尾
>
> 如果成功移动文件指针，则该函数返回文件指针移到的位置。如果文件指针移动失败，则返回 -1。

例如，以下代码将文件指针移到文件开头：

```jsx showLineNumbers
lseek(fd, 0, SEEK_SET);
```

以下代码将文件指针移到当前位置的下一个字节：

```jsx showLineNumbers
lseek(fd, 1, SEEK_CUR);
```

以下代码将文件指针移到文件末尾的前一个字节：

```jsx showLineNumbers
lseek(fd, -1, SEEK_END);
```

注意：`lseek()` 函数并不会修改文件的大小，它只是移动了文件指针。

### 7. 示例代码

```jsx showLineNumbers
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define BUF_SIZE 1024

int main(int argc, char *argv[])
{
    // 打开文件
    int fd = open("hello.txt", O_RDWR | O_CREAT, 0644);
    if (fd == -1) {
        // 文件打开失败
        perror("open() fail");
        exit(EXIT_FAILURE);
    }

    // 向文件中写入数据
	char *msg = "Hello, world!\n";
	size_t len = strlen(msg);
	if (write(fd, msg, len) != len) {
	// 写入文件失败
		perror("write() fail");
		exit(EXIT_FAILURE);
	}
	// 将文件指针移到文件开头
	if (lseek(fd, 0, SEEK_SET) == -1) {
		// 文件指针移动失败
		perror("lseek() fail");
		exit(EXIT_FAILURE);
	}

	// 循环读取文件中的数据
	char buf[BUF_SIZE];
	ssize_t numRead;
	while ((numRead = read(fd, buf, BUF_SIZE)) > 0) {
		// 将读取的数据写入标准输出
		if (write(STDOUT_FILENO, buf, numRead) != numRead){
			// 写入标准输出失败
			perror("write() fail");
			exit(EXIT_FAILURE);
		}
	}

	if (numRead == -1) {
		// 读取文件失败
		perror("read() fail");
		exit(EXIT_FAILURE);
	}

	// 关闭文件
    int ret = close(fd);
	if (ret == -1){
		// 文件关闭失败
		perror("close() fail");
		exit(EXIT_FAILURE);
	}

	return 0;
}
```











